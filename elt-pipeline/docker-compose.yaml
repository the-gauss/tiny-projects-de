services:
  source_postgres:
    image: postgres:15
    ports:
      - "5433:5432"
    networks:
      - elt_network
    environment:
      POSTGRES_DB: ${SRC_DB_NAME}
      POSTGRES_USER: ${SRC_DB_USER}
      POSTGRES_PASSWORD: ${SRC_DB_PASS}
    # The volumes key can either contain the storage (the actual db) or a script. Postgres image is designed
    # to run the `/docker-entrypoint-initdb.d/init.sql` script iff the database is empty. This also handles creating user and DB with the environment variables above.
    volumes:
      - ./source_db_init/init.sql:/docker-entrypoint-initdb.d/init.sql
      # Use volumes when you want to persist data between container restarts and enable file sharing between host and container. 
      # In the current form, there is no persistence of the database data. If you restart the container, the data will be lost unless you use a volume for the Postgres data directory.
      # For actual data persistence, you could use a named volume like:
      # - pgdata_source:/var/lib/postgresql/data and then define it under a volumes: key at the bottom of this file.

  destination_postgres:
    image: postgres:15
    ports:
      - "5434:5432"
    networks:
      - elt_network
    environment:
      POSTGRES_DB: ${DEST_DB_NAME}  
      POSTGRES_USER: ${DEST_DB_USER}
      POSTGRES_PASSWORD: ${DEST_DB_PASS}
    # We didn't need volumes here since we don't need to initialize the destination DB with any script or persist data. It is created empty.

    # source_postgres and destination_postgres have no depends_on, so they start first. 
    # The elt_script service depends on both of them to ensure they are up before it runs.
    # The dbt service depends on elt_script to ensure the ELT process is complete before dbt runs; and this dbt starts last (so far).
    # Use the depends_on key to control startup order of services.
  
  elt_script:
    build:
      context: ./ # Defines the build context, i.e., the root directory for the build. The COPY and ADD instructions in the Dockerfile are relative to this path.
      dockerfile: elt/Dockerfile
    env_file:
      - .env
    networks:
      - elt_network
    depends_on:
      - source_postgres
      - destination_postgres
    # We didn't need volumes here since the script is run once when the container starts and doesn't need to persist any data. It only need code, which is already baked into the image.

  dbt:
    # image: ghcr.io/dbt-labs/dbt-postgres:latest
    # command: [  # When a container starts, it runs the CMD specified in its Dockerfile. Here we override that command to run dbt commands instead.
    #   'run',  # We use specific commands because the default command in the dbt image is just 'dbt', which would start an interactive shell. This is set through the ENTRYPOINT in the Dockerfile of the dbt image.
    #   # dbt run compiles models/*.sql and runs them against the destination database (or DWH). It creates tables/views (based on `materialized` in `dbt_project.yml`) as per the model definitions.
    #   '--profiles-dir',
    #   '/root',  # We have specified this to be the profiles directory, and mapped the host's ~/.dbt to /root in the volumes section below; this is where it finds the profiles.yml file.
    #   '--project-dir',  # Again, we specify the project directory where the dbt_project.yml file is located.
    #   '/dbt'
    # image did not work on macOS due to some architecture issues (M1/M2/M3 chips). Hence, we build a custom image instead.
    build:
      context: .
      dockerfile: custom_postgres/Dockerfile.dbt
    command: [
      "run",
      "--profiles-dir",
      "/root/.dbt",
      "--project-dir",
      "/dbt"
    ]
    networks:
      - elt_network
    volumes:
      - ./custom_postgres:/dbt
      - ~/.dbt:/root/.dbt
    depends_on:
      - elt_script  # dbt assumes that the ELT script has already run and the data is in the destination Postgres.
    env_file:
      - .env
    environment:
      DBT_PROFILE: ${DBT_PROFILE}
      DBT_TARGET: ${DBT_TARGET}
      # Did not use env_file here becuase unlike Python scripts, dbt does not automatically read from .env files. Instead, we pass the necessary environment variables directly.
      

networks:
  elt_network:
    driver: bridge  # Other values are 'host', 'overlay', etc. Use 'host' for no isolation between host and container. Use 'bridge' for isolated networks. Use 'overlay' for multi-host networking (Docker Swarm).

#volumes:
#  pgdata_source: (the named volume for source Postgres data persistence would be defined here)
